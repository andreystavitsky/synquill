// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by synquill aggregate_builder

part of '../synquill.generated.dart';

/// Generated ID management extension for Post
extension PostIdManagement on Post {
  /// Whether this model uses server-generated IDs
  bool get $usesServerGeneratedId => 
      false;

  /// Create a new model instance with a different ID
  /// This is used during ID negotiation when server assigns a different ID
  Post $replaceIdEverywhere(String newId) {
    final json = toJson();
    json['id'] = newId;
    return fromJson(json);
  }

  /// Whether this model currently has a temporary ID 
  /// (always false for client-generated IDs)
  bool get $hasTemporaryId => false;

  /// Get temporary client ID for this model 
  /// (always null for client-generated IDs)
  String? get $temporaryClientId => null;
}


/// Generated extension methods for loading 
/// related objects for Post
extension PostRelationExtensions on Post {
  /// Logger for the Post relation extensions.
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('PostRelationExtensions');
    }
  }

  /// Load related User object
  /// Uses foreign key field 'userId'
  Future<User?> loadUser({
    DataLoadPolicy? loadPolicy,
    Map<String, String>? headers,
    Map<String, dynamic>? extra,
  }) async {
    try {
      final foreignKey = userId;
      if (foreignKey == null) return null;
      final database = DatabaseProvider.instance;
      final repository = SynquillRepositoryProvider
          .getFrom<User>(database);
      return await repository.findOne(
        foreignKey.toString(),
        loadPolicy: loadPolicy ?? DataLoadPolicy.localOnly,
        headers: headers,
        extra: extra,
      );
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to load User for $runtimeType[$id]',
        e,
        stackTrace,
      );
      rethrow;
    }
  }

  /// Watch related User object as a stream
  /// Uses foreign key field 'userId'
  /// Automatically switches to new target when foreign key changes
  Stream<User?> watchUser({
    DataLoadPolicy? loadPolicy,
    Map<String, String>? headers,
    Map<String, dynamic>? extra,
  }) {
    try {
      final database = DatabaseProvider.instance;
      final sourceRepository = SynquillRepositoryProvider
          .getFrom<Post>(database);
      final targetRepository = SynquillRepositoryProvider
          .getFrom<User>(database);

      // Watch the source object for changes in foreign key
      return sourceRepository.watchOne(id)
          .switchMap((sourceObject) {
        if (sourceObject == null) {
          return Stream.value(null);
        }

        final foreignKey = sourceObject.userId;
        if (foreignKey == null) {
          return Stream.value(null);
        }

        // Switch to watching the target object
        return targetRepository.watchOne(
          foreignKey.toString(),
          loadPolicy: loadPolicy ?? DataLoadPolicy.localOnly,
        );
      });
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to watch User for Post[$id]',
        e,
        stackTrace,
      );
      rethrow;
    }
  }

}


/// Generated ID management extension for LocalNote
extension LocalNoteIdManagement on LocalNote {
  /// Whether this model uses server-generated IDs
  bool get $usesServerGeneratedId => 
      false;

  /// Create a new model instance with a different ID
  /// This is used during ID negotiation when server assigns a different ID
  LocalNote $replaceIdEverywhere(String newId) {
    final json = toJson();
    json['id'] = newId;
    return fromJson(json);
  }

  /// Whether this model currently has a temporary ID 
  /// (always false for client-generated IDs)
  bool get $hasTemporaryId => false;

  /// Get temporary client ID for this model 
  /// (always null for client-generated IDs)
  String? get $temporaryClientId => null;
}


/// Generated extension methods for loading 
/// related objects for LocalNote
extension LocalNoteRelationExtensions on LocalNote {
  /// Logger for the LocalNote relation extensions.
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('LocalNoteRelationExtensions');
    }
  }

  /// Load related User object
  /// Uses foreign key field 'ownerId'
  Future<User?> loadUser({
    DataLoadPolicy? loadPolicy,
    Map<String, String>? headers,
    Map<String, dynamic>? extra,
  }) async {
    try {
      final foreignKey = ownerId;
      if (foreignKey == null) return null;
      final database = DatabaseProvider.instance;
      final repository = SynquillRepositoryProvider
          .getFrom<User>(database);
      return await repository.findOne(
        foreignKey.toString(),
        loadPolicy: loadPolicy ?? DataLoadPolicy.localOnly,
        headers: headers,
        extra: extra,
      );
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to load User for $runtimeType[$id]',
        e,
        stackTrace,
      );
      rethrow;
    }
  }

  /// Watch related User object as a stream
  /// Uses foreign key field 'ownerId'
  /// Automatically switches to new target when foreign key changes
  Stream<User?> watchUser({
    DataLoadPolicy? loadPolicy,
    Map<String, String>? headers,
    Map<String, dynamic>? extra,
  }) {
    try {
      final database = DatabaseProvider.instance;
      final sourceRepository = SynquillRepositoryProvider
          .getFrom<LocalNote>(database);
      final targetRepository = SynquillRepositoryProvider
          .getFrom<User>(database);

      // Watch the source object for changes in foreign key
      return sourceRepository.watchOne(id)
          .switchMap((sourceObject) {
        if (sourceObject == null) {
          return Stream.value(null);
        }

        final foreignKey = sourceObject.ownerId;
        if (foreignKey == null) {
          return Stream.value(null);
        }

        // Switch to watching the target object
        return targetRepository.watchOne(
          foreignKey.toString(),
          loadPolicy: loadPolicy ?? DataLoadPolicy.localOnly,
        );
      });
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to watch User for LocalNote[$id]',
        e,
        stackTrace,
      );
      rethrow;
    }
  }

}


/// Generated ID management extension for PlainModel
extension PlainModelIdManagement on PlainModel {
  /// Whether this model uses server-generated IDs
  bool get $usesServerGeneratedId => 
      false;

  /// Create a new model instance with a different ID
  /// This is used during ID negotiation when server assigns a different ID
  PlainModel $replaceIdEverywhere(String newId) {
    final json = toJson();
    json['id'] = newId;
    return fromJson(json);
  }

  /// Whether this model currently has a temporary ID 
  /// (always false for client-generated IDs)
  bool get $hasTemporaryId => false;

  /// Get temporary client ID for this model 
  /// (always null for client-generated IDs)
  String? get $temporaryClientId => null;
}




/// Generated ID management extension for User
extension UserIdManagement on User {
  /// Whether this model uses server-generated IDs
  bool get $usesServerGeneratedId => 
      false;

  /// Create a new model instance with a different ID
  /// This is used during ID negotiation when server assigns a different ID
  User $replaceIdEverywhere(String newId) {
    final json = toJson();
    json['id'] = newId;
    return fromJson(json);
  }

  /// Whether this model currently has a temporary ID 
  /// (always false for client-generated IDs)
  bool get $hasTemporaryId => false;

  /// Get temporary client ID for this model 
  /// (always null for client-generated IDs)
  String? get $temporaryClientId => null;
}


/// Generated extension methods for loading 
/// related objects for User
extension UserRelationExtensions on User {
  /// Logger for the User relation extensions.
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('UserRelationExtensions');
    }
  }

  /// Load related Todos objects
  /// Uses mappedBy field 'userId' in Todo
  Future<List<Todo>> loadTodos({
    DataLoadPolicy? loadPolicy,
    Map<String, String>? headers,
    Map<String, dynamic>? extra,
    QueryParams? queryParams,
  }) async {
    try {
      final database = DatabaseProvider.instance;
      final repository = SynquillRepositoryProvider
          .getFrom<Todo>(database);
      
      // Create required filter for the relation
      final requiredFilter = TodoFields.userId.equals(id);
      
      // Merge user queryParams with required filter
      final mergedQueryParams = QueryParams.withRequiredFilter(
        queryParams,
        requiredFilter,
      );
      
      return await repository.findAll(
        loadPolicy: loadPolicy ?? DataLoadPolicy.localOnly,
        queryParams: mergedQueryParams,
        headers: headers,
        extra: extra,
      );
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to load Todos for $runtimeType[$id]', e, stackTrace);
      rethrow;
    }
  }

  /// Watch related Todos objects as a stream
  /// Uses mappedBy field 'userId' in Todo
  Stream<List<Todo>> watchTodos({
    QueryParams? queryParams,
  }) {
    try {
      final database = DatabaseProvider.instance;
      final repository = SynquillRepositoryProvider
          .getFrom<Todo>(database);
      
      // Create required filter for the relation
      final requiredFilter = TodoFields.userId.equals(id);
      
      // Merge user queryParams with required filter
      final mergedQueryParams = QueryParams.withRequiredFilter(
        queryParams,
        requiredFilter,
      );
      
      return repository.watchAll(
        queryParams: mergedQueryParams,
      );
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to watchTodos for $runtimeType[$id]', e, stackTrace);
      rethrow;
    }
  }

  /// Load related Posts objects
  /// Uses mappedBy field 'userId' in Post
  Future<List<Post>> loadPosts({
    DataLoadPolicy? loadPolicy,
    Map<String, String>? headers,
    Map<String, dynamic>? extra,
    QueryParams? queryParams,
  }) async {
    try {
      final database = DatabaseProvider.instance;
      final repository = SynquillRepositoryProvider
          .getFrom<Post>(database);
      
      // Create required filter for the relation
      final requiredFilter = PostFields.userId.equals(id);
      
      // Merge user queryParams with required filter
      final mergedQueryParams = QueryParams.withRequiredFilter(
        queryParams,
        requiredFilter,
      );
      
      return await repository.findAll(
        loadPolicy: loadPolicy ?? DataLoadPolicy.localOnly,
        queryParams: mergedQueryParams,
        headers: headers,
        extra: extra,
      );
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to load Posts for $runtimeType[$id]', e, stackTrace);
      rethrow;
    }
  }

  /// Watch related Posts objects as a stream
  /// Uses mappedBy field 'userId' in Post
  Stream<List<Post>> watchPosts({
    QueryParams? queryParams,
  }) {
    try {
      final database = DatabaseProvider.instance;
      final repository = SynquillRepositoryProvider
          .getFrom<Post>(database);
      
      // Create required filter for the relation
      final requiredFilter = PostFields.userId.equals(id);
      
      // Merge user queryParams with required filter
      final mergedQueryParams = QueryParams.withRequiredFilter(
        queryParams,
        requiredFilter,
      );
      
      return repository.watchAll(
        queryParams: mergedQueryParams,
      );
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to watchPosts for $runtimeType[$id]', e, stackTrace);
      rethrow;
    }
  }

  /// Load related LocalNotes objects
  /// Uses mappedBy field 'ownerId' in LocalNote
  Future<List<LocalNote>> loadLocalNotes({
    DataLoadPolicy? loadPolicy,
    Map<String, String>? headers,
    Map<String, dynamic>? extra,
    QueryParams? queryParams,
  }) async {
    try {
      final database = DatabaseProvider.instance;
      final repository = SynquillRepositoryProvider
          .getFrom<LocalNote>(database);
      
      // Create required filter for the relation
      final requiredFilter = LocalNoteFields.ownerId.equals(id);
      
      // Merge user queryParams with required filter
      final mergedQueryParams = QueryParams.withRequiredFilter(
        queryParams,
        requiredFilter,
      );
      
      return await repository.findAll(
        loadPolicy: loadPolicy ?? DataLoadPolicy.localOnly,
        queryParams: mergedQueryParams,
        headers: headers,
        extra: extra,
      );
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to load LocalNotes for $runtimeType[$id]', e, stackTrace);
      rethrow;
    }
  }

  /// Watch related LocalNotes objects as a stream
  /// Uses mappedBy field 'ownerId' in LocalNote
  Stream<List<LocalNote>> watchLocalNotes({
    QueryParams? queryParams,
  }) {
    try {
      final database = DatabaseProvider.instance;
      final repository = SynquillRepositoryProvider
          .getFrom<LocalNote>(database);
      
      // Create required filter for the relation
      final requiredFilter = LocalNoteFields.ownerId.equals(id);
      
      // Merge user queryParams with required filter
      final mergedQueryParams = QueryParams.withRequiredFilter(
        queryParams,
        requiredFilter,
      );
      
      return repository.watchAll(
        queryParams: mergedQueryParams,
      );
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to watchLocalNotes for $runtimeType[$id]', e, stackTrace);
      rethrow;
    }
  }

}


/// Generated ID management extension for Todo
extension TodoIdManagement on Todo {
  /// Whether this model uses server-generated IDs
  bool get $usesServerGeneratedId => 
      false;

  /// Create a new model instance with a different ID
  /// This is used during ID negotiation when server assigns a different ID
  Todo $replaceIdEverywhere(String newId) {
    final json = toJson();
    json['id'] = newId;
    return fromJson(json);
  }

  /// Whether this model currently has a temporary ID 
  /// (always false for client-generated IDs)
  bool get $hasTemporaryId => false;

  /// Get temporary client ID for this model 
  /// (always null for client-generated IDs)
  String? get $temporaryClientId => null;
}


/// Generated extension methods for loading 
/// related objects for Todo
extension TodoRelationExtensions on Todo {
  /// Logger for the Todo relation extensions.
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('TodoRelationExtensions');
    }
  }

  /// Load related User object
  /// Uses foreign key field 'userId'
  Future<User?> loadUser({
    DataLoadPolicy? loadPolicy,
    Map<String, String>? headers,
    Map<String, dynamic>? extra,
  }) async {
    try {
      final foreignKey = userId;
      if (foreignKey == null) return null;
      final database = DatabaseProvider.instance;
      final repository = SynquillRepositoryProvider
          .getFrom<User>(database);
      return await repository.findOne(
        foreignKey.toString(),
        loadPolicy: loadPolicy ?? DataLoadPolicy.localOnly,
        headers: headers,
        extra: extra,
      );
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to load User for $runtimeType[$id]',
        e,
        stackTrace,
      );
      rethrow;
    }
  }

  /// Watch related User object as a stream
  /// Uses foreign key field 'userId'
  /// Automatically switches to new target when foreign key changes
  Stream<User?> watchUser({
    DataLoadPolicy? loadPolicy,
    Map<String, String>? headers,
    Map<String, dynamic>? extra,
  }) {
    try {
      final database = DatabaseProvider.instance;
      final sourceRepository = SynquillRepositoryProvider
          .getFrom<Todo>(database);
      final targetRepository = SynquillRepositoryProvider
          .getFrom<User>(database);

      // Watch the source object for changes in foreign key
      return sourceRepository.watchOne(id)
          .switchMap((sourceObject) {
        if (sourceObject == null) {
          return Stream.value(null);
        }

        final foreignKey = sourceObject.userId;
        if (foreignKey == null) {
          return Stream.value(null);
        }

        // Switch to watching the target object
        return targetRepository.watchOne(
          foreignKey.toString(),
          loadPolicy: loadPolicy ?? DataLoadPolicy.localOnly,
        );
      });
    } catch (e, stackTrace) {
      _log.severe(
        'Failed to watch User for Todo[$id]',
        e,
        stackTrace,
      );
      rethrow;
    }
  }

}


