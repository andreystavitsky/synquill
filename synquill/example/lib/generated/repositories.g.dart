// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by synquill aggregate_builder

part of '../synquill.generated.dart';

/// Concrete repository implementation for Post
class PostRepository extends SynquillRepositoryBase<Post> 
    with RepositoryHelpersMixin<Post> {
  late final PostDao _dao;
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('PostRepository');
    }
  }

  /// Creates a new Post repository instance
  /// 
  /// [db] The database instance to use for data operations
  PostRepository(super.db) {
    _dao = PostDao(db as SynquillDatabase);
  }

  @override
  DatabaseAccessor get dao => _dao;

  @override
  ApiAdapterBase<Post> get apiAdapter {
    return _PostAdapter();
  }

  @override
  Future<Post?> fetchFromRemote(
    String id, {
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    try {
      final result = await apiAdapter.findOne(
        id, 
        queryParams: queryParams,
        extra: extra
      );
      _log.fine(
        'fetchFromRemote() for Post successful: found item with id $id'
      );
      return result;
    } on ApiExceptionNotFound {
      _log.fine(
        'fetchFromRemote() for Post: item with id $id not found in '
        'remote API'
      );
      // Rethrow the exception so SynquillRepositoryBase can remove the 
      // item from local storage
      rethrow;
    } on ApiExceptionGone {
      _log.fine(
        'fetchFromRemote() for Post: item with id $id is gone from '
        'remote API'
      );
      // Rethrow the exception so SynquillRepositoryBase can remove the 
      // item from local storage
      rethrow;
    } catch (e, stackTrace) {
      _log.warning(
        'fetchFromRemote() for Post failed for id $id', 
        e, 
        stackTrace
      );
      rethrow;
    }
  }

  @override
  Future<List<Post>> fetchAllFromRemote({
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    try {
      final result = await apiAdapter.findAll(
        queryParams: queryParams, 
        extra: extra
      );
      _log.fine(
        'fetchAllFromRemote() for Post successful: '
        'found ${result.length} items'
      );
      return result;
    } catch (e, stackTrace) {
      _log.warning(
        'fetchAllFromRemote() for Post failed', 
        e, 
        stackTrace
      );
      rethrow;
    }
  }
}


/// Local-only repository implementation for LocalNote
/// This repository only works with local database and does not sync with
/// remote API
class LocalNoteRepository extends SynquillRepositoryBase<LocalNote> 
    with RepositoryHelpersMixin<LocalNote> {
  late final LocalNoteDao _dao;
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('LocalNoteRepository');
    }
  }

  /// Creates a new LocalNote repository instance (local-only mode)
  /// 
  /// [db] The database instance to use for data operations
  LocalNoteRepository(super.db) {
    _dao = LocalNoteDao(db as SynquillDatabase);
  }

  @override
  DatabaseAccessor get dao => _dao;

  @override
  ApiAdapterBase<LocalNote> get apiAdapter {
    throw UnsupportedError(
      'API adapter not available for local-only repository LocalNote. '
      'This repository was configured with localOnly=true and does not '
      'support remote operations.'
    );
  }

  @override
  Future<LocalNote?> fetchFromRemote(
    String id, {
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    _log.fine(
      'fetchFromRemote() called on local-only repository for LocalNote, '
      'returning null'
    );
    return null;
  }

  @override
  Future<List<LocalNote>> fetchAllFromRemote({
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    _log.fine(
      'fetchAllFromRemote() called on local-only repository for LocalNote, '
      'returning empty list'
    );
    return [];
  }
}


/// Concrete repository implementation for PlainModel
class PlainModelRepository extends SynquillRepositoryBase<PlainModel> 
    with RepositoryHelpersMixin<PlainModel> {
  late final PlainModelDao _dao;
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('PlainModelRepository');
    }
  }

  /// Creates a new PlainModel repository instance
  /// 
  /// [db] The database instance to use for data operations
  PlainModelRepository(super.db) {
    _dao = PlainModelDao(db as SynquillDatabase);
  }

  @override
  DatabaseAccessor get dao => _dao;

  @override
  ApiAdapterBase<PlainModel> get apiAdapter {
    throw UnimplementedError('No adapters specified for PlainModel');
  }

  @override
  Future<PlainModel?> fetchFromRemote(
    String id, {
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    try {
      final result = await apiAdapter.findOne(
        id, 
        queryParams: queryParams,
        extra: extra
      );
      _log.fine(
        'fetchFromRemote() for PlainModel successful: found item with id $id'
      );
      return result;
    } on ApiExceptionNotFound {
      _log.fine(
        'fetchFromRemote() for PlainModel: item with id $id not found in '
        'remote API'
      );
      // Rethrow the exception so SynquillRepositoryBase can remove the 
      // item from local storage
      rethrow;
    } on ApiExceptionGone {
      _log.fine(
        'fetchFromRemote() for PlainModel: item with id $id is gone from '
        'remote API'
      );
      // Rethrow the exception so SynquillRepositoryBase can remove the 
      // item from local storage
      rethrow;
    } catch (e, stackTrace) {
      _log.warning(
        'fetchFromRemote() for PlainModel failed for id $id', 
        e, 
        stackTrace
      );
      rethrow;
    }
  }

  @override
  Future<List<PlainModel>> fetchAllFromRemote({
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    try {
      final result = await apiAdapter.findAll(
        queryParams: queryParams, 
        extra: extra
      );
      _log.fine(
        'fetchAllFromRemote() for PlainModel successful: '
        'found ${result.length} items'
      );
      return result;
    } catch (e, stackTrace) {
      _log.warning(
        'fetchAllFromRemote() for PlainModel failed', 
        e, 
        stackTrace
      );
      rethrow;
    }
  }
}


/// Concrete repository implementation for User
class UserRepository extends SynquillRepositoryBase<User> 
    with RepositoryHelpersMixin<User> {
  late final UserDao _dao;
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('UserRepository');
    }
  }

  /// Creates a new User repository instance
  /// 
  /// [db] The database instance to use for data operations
  UserRepository(super.db) {
    _dao = UserDao(db as SynquillDatabase);
  }

  @override
  DatabaseAccessor get dao => _dao;

  @override
  ApiAdapterBase<User> get apiAdapter {
    return _UserAdapter();
  }

  @override
  Future<User?> fetchFromRemote(
    String id, {
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    try {
      final result = await apiAdapter.findOne(
        id, 
        queryParams: queryParams,
        extra: extra
      );
      _log.fine(
        'fetchFromRemote() for User successful: found item with id $id'
      );
      return result;
    } on ApiExceptionNotFound {
      _log.fine(
        'fetchFromRemote() for User: item with id $id not found in '
        'remote API'
      );
      // Rethrow the exception so SynquillRepositoryBase can remove the 
      // item from local storage
      rethrow;
    } on ApiExceptionGone {
      _log.fine(
        'fetchFromRemote() for User: item with id $id is gone from '
        'remote API'
      );
      // Rethrow the exception so SynquillRepositoryBase can remove the 
      // item from local storage
      rethrow;
    } catch (e, stackTrace) {
      _log.warning(
        'fetchFromRemote() for User failed for id $id', 
        e, 
        stackTrace
      );
      rethrow;
    }
  }

  @override
  Future<List<User>> fetchAllFromRemote({
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    try {
      final result = await apiAdapter.findAll(
        queryParams: queryParams, 
        extra: extra
      );
      _log.fine(
        'fetchAllFromRemote() for User successful: '
        'found ${result.length} items'
      );
      return result;
    } catch (e, stackTrace) {
      _log.warning(
        'fetchAllFromRemote() for User failed', 
        e, 
        stackTrace
      );
      rethrow;
    }
  }
}


/// Concrete repository implementation for Todo
class TodoRepository extends SynquillRepositoryBase<Todo> 
    with RepositoryHelpersMixin<Todo> {
  late final TodoDao _dao;
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('TodoRepository');
    }
  }

  /// Creates a new Todo repository instance
  /// 
  /// [db] The database instance to use for data operations
  TodoRepository(super.db) {
    _dao = TodoDao(db as SynquillDatabase);
  }

  @override
  DatabaseAccessor get dao => _dao;

  @override
  ApiAdapterBase<Todo> get apiAdapter {
    return _TodoAdapter();
  }

  @override
  Future<Todo?> fetchFromRemote(
    String id, {
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    try {
      final result = await apiAdapter.findOne(
        id, 
        queryParams: queryParams,
        extra: extra
      );
      _log.fine(
        'fetchFromRemote() for Todo successful: found item with id $id'
      );
      return result;
    } on ApiExceptionNotFound {
      _log.fine(
        'fetchFromRemote() for Todo: item with id $id not found in '
        'remote API'
      );
      // Rethrow the exception so SynquillRepositoryBase can remove the 
      // item from local storage
      rethrow;
    } on ApiExceptionGone {
      _log.fine(
        'fetchFromRemote() for Todo: item with id $id is gone from '
        'remote API'
      );
      // Rethrow the exception so SynquillRepositoryBase can remove the 
      // item from local storage
      rethrow;
    } catch (e, stackTrace) {
      _log.warning(
        'fetchFromRemote() for Todo failed for id $id', 
        e, 
        stackTrace
      );
      rethrow;
    }
  }

  @override
  Future<List<Todo>> fetchAllFromRemote({
    QueryParams? queryParams, 
    Map<String, String>? headers, 
    Map<String, dynamic>? extra
  }) async {
    try {
      final result = await apiAdapter.findAll(
        queryParams: queryParams, 
        extra: extra
      );
      _log.fine(
        'fetchAllFromRemote() for Todo successful: '
        'found ${result.length} items'
      );
      return result;
    } catch (e, stackTrace) {
      _log.warning(
        'fetchAllFromRemote() for Todo failed', 
        e, 
        stackTrace
      );
      rethrow;
    }
  }
}


/// Register all repository factories with SynquillRepositoryProvider
void registerAllRepositories() {
  SynquillRepositoryProvider.register<Post>(
    (db) => PostRepository(db),
  );
  SynquillRepositoryProvider.register<LocalNote>(
    (db) => LocalNoteRepository(db),
  );
  SynquillRepositoryProvider.register<PlainModel>(
    (db) => PlainModelRepository(db),
  );
  SynquillRepositoryProvider.register<User>(
    (db) => UserRepository(db),
  );
  SynquillRepositoryProvider.register<Todo>(
    (db) => TodoRepository(db),
  );
}

/// Register all model dependencies for hierarchical sync ordering
void registerModelDependencies() {
  // Post depends on User via userId
  DependencyResolver.registerDependency('Post', 'User');
  // LocalNote depends on User via ownerId
  DependencyResolver.registerDependency('LocalNote', 'User');
  // Todo depends on User via userId
  DependencyResolver.registerDependency('Todo', 'User');
}

/// Initialize the synced storage system
/// This function should be accessible from background isolates
@pragma('vm:entry-point')
void initializeSynquillStorage(GeneratedDatabase database) {
  // Set up global database access
  DatabaseProvider.setInstance(database);
  
  // Register all repository factories
  registerAllRepositories();
  
  // Register model dependencies for hierarchical sync
  registerModelDependencies();
  
  // Register model relations (cascade delete and foreign keys)
  registerModelRelations();
  
}

/// Register all model relations
void registerModelRelations() {
  // === CASCADE DELETE RELATIONS ===

  // === FOREIGN KEY RELATIONS ===
  // Register foreign key relations for User
  ModelInfoRegistryProvider.registerForeignKeyRelations(
    'User',
    [
      const ForeignKeyRelation(
        fieldName: 'userId',
        targetType: 'User',
        sourceTable: 'posts',
      ),
      const ForeignKeyRelation(
        fieldName: 'userId',
        targetType: 'User',
        sourceTable: 'posts',
      ),
      const ForeignKeyRelation(
        fieldName: 'ownerId',
        targetType: 'User',
        sourceTable: 'local_notes',
      ),
      const ForeignKeyRelation(
        fieldName: 'ownerId',
        targetType: 'User',
        sourceTable: 'local_notes',
      ),
      const ForeignKeyRelation(
        fieldName: 'userId',
        targetType: 'User',
        sourceTable: 'todos',
      ),
      const ForeignKeyRelation(
        fieldName: 'userId',
        targetType: 'User',
        sourceTable: 'todos',
      ),
    ],
  );
}

/// Extension providing convenient repository access on SynquillStorage
extension SynquillStorageRepositories on SynquillStorage {
  /// Access repository for Post models
  PostRepository get posts {
    return getRepository<Post>() as PostRepository;
  }

  /// Access repository for LocalNote models
  LocalNoteRepository get localNotes {
    return getRepository<LocalNote>() as LocalNoteRepository;
  }

  /// Access repository for PlainModel models
  PlainModelRepository get plainModels {
    return getRepository<PlainModel>() as PlainModelRepository;
  }

  /// Access repository for User models
  UserRepository get users {
    return getRepository<User>() as UserRepository;
  }

  /// Access repository for Todo models
  TodoRepository get todos {
    return getRepository<Todo>() as TodoRepository;
  }

}


