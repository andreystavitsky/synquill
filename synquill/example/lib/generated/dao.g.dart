// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by synquill aggregate_builder

part of 'database.generated.dart';

/// Helper mixin for DAO classes to provide filtering and query operations
mixin DaoHelpersMixin<Tbl extends Table, D> 
  on DatabaseAccessor<SynquillDatabase> {
  /// Apply query parameters (filters, sorting, pagination) to a query
  void applyQueryParams(
    SimpleSelectStatement<Tbl, D> query,
    QueryParams queryParams,
  ) {
    // Apply filters
    for (final filter in queryParams.filters) {
      applyFilter(query, filter);
    }

    // Apply sorting
    if (queryParams.sorts.isNotEmpty) {
      query.orderBy([
        for (final sort in queryParams.sorts)
          (t) => createOrderingTerm(sort, t),
      ]);
    }

    // Apply pagination
    if (queryParams.pagination != null) {
      final pagination = queryParams.pagination!;
      final limit = pagination.limit;
      final offset = pagination.offset;
      if (limit != null && offset != null) {
        query.limit(limit, offset: offset);
      } else if (limit != null) {
        query.limit(limit);
      }
    }
  }

  /// Get column expression for a field name
  Expression<Object>? getColumnForField(String fieldName);

  /// Get the data type for a field name
  String? getFieldType(String fieldName);

  /// Apply a single filter to the query
  void applyFilter(
    SimpleSelectStatement<Tbl, D> query,
    FilterCondition filter,
  ) {
    final column = getColumnForField(filter.field.fieldName);
    if (column == null) {
      throw ArgumentError('Unknown field: ${filter.field.fieldName}');
    }

    final fieldType = getFieldType(filter.field.fieldName);
    applyFilterByType(query, column, filter, fieldType);
  }

  /// Apply filter based on field type
  void applyFilterByType(
    SimpleSelectStatement<Tbl, D> query,
    Expression<Object> column,
    FilterCondition filter,
    String? fieldType,
  ) {
    switch (filter.operator) {
      case FilterOperator.equals:
        _applySingleValueFilter(query, column, filter, fieldType, 
          (col, val) => col.equals(val));
        break;
      case FilterOperator.notEquals:
        _applySingleValueFilter(query, column, filter, fieldType, 
          (col, val) => col.equals(val).not());
        break;
      case FilterOperator.contains:
        if (fieldType == 'String' && filter.value is SingleValue) {
          final value = (filter.value as SingleValue).value as String;
          query.where((t) => (column as Expression<String>).contains(value));
        }
        break;
      case FilterOperator.startsWith:
        if (fieldType == 'String' && filter.value is SingleValue) {
          final value = (filter.value as SingleValue).value as String;
          query.where((t) => (column as Expression<String>).like('$value%'));
        }
        break;
      case FilterOperator.endsWith:
        if (fieldType == 'String' && filter.value is SingleValue) {
          final value = (filter.value as SingleValue).value as String;
          query.where((t) => (column as Expression<String>).like('%$value'));
        }
        break;
      case FilterOperator.greaterThan:
        _applyComparisonFilter(query, column, filter, fieldType, 
        _applyGreaterThan);
        break;
      case FilterOperator.greaterThanOrEqual:
        _applyComparisonFilter(query, column, filter, fieldType, 
        _applyGreaterThanOrEqual);
        break;
      case FilterOperator.lessThan:
        _applyComparisonFilter(query, column, filter, fieldType, 
        _applyLessThan);
        break;
      case FilterOperator.lessThanOrEqual:
        _applyComparisonFilter(query, column, filter, fieldType, 
        _applyLessThanOrEqual);
        break;
      case FilterOperator.isNull:
        query.where((t) => column.isNull());
        break;
      case FilterOperator.isNotNull:
        query.where((t) => column.isNotNull());
        break;
      case FilterOperator.inList:
        _applyListFilter(query, column, filter, fieldType, true);
        break;
      case FilterOperator.notInList:
        _applyListFilter(query, column, filter, fieldType, false);
        break;
    }
  }

  /// Apply filter for single value operations (equals, notEquals)
  void _applySingleValueFilter(
    SimpleSelectStatement<Tbl, D> query,
    Expression<Object> column,
    FilterCondition filter,
    String? fieldType,
    Expression<bool> Function(Expression<Object>, Object) operation,
  ) {
    if (filter.value is SingleValue) {
      if (fieldType == 'SyncStatus') {
        final value = (filter.value as SingleValue).value;
        final statusName = value is SyncStatus ? value.name : value;
        query.where((t) => operation(column, statusName));
      } else {
        final value = (filter.value as SingleValue).value;
        query.where((t) => operation(column, value));
      }
    }
  }

  /// Apply comparison filter for numeric and DateTime types
  void _applyComparisonFilter(
    SimpleSelectStatement<Tbl, D> query,
    Expression<Object> column,
    FilterCondition filter,
    String? fieldType,
    void Function(SimpleSelectStatement<Tbl, D>, 
    Expression<Object>, Object, String) operation,
  ) {
    if (filter.value is SingleValue) {
      final value = (filter.value as SingleValue).value;
      if (fieldType != null && (fieldType == 'int' 
        || fieldType == 'double' || fieldType == 'DateTime')) {
        operation(query, column, value, fieldType);
      }
    }
  }

  /// Apply greater than operation with type safety
  void _applyGreaterThan(
    SimpleSelectStatement<Tbl, D> query,
    Expression<Object> column,
    Object value,
    String fieldType,
  ) {
    switch (fieldType) {
      case 'int':
        query.where((t) => (column as Expression<int>)
          .isBiggerThan(Variable<int>(value as int)));
        break;
      case 'double':
        query.where((t) => (column as Expression<double>)
          .isBiggerThan(Variable<double>(value as double)));
        break;
      case 'DateTime':
        query.where((t) => (column as Expression<DateTime>)
          .isBiggerThan(Variable<DateTime>(value as DateTime)));
        break;
    }
  }

  /// Apply greater than or equal operation with type safety
  void _applyGreaterThanOrEqual(
    SimpleSelectStatement<Tbl, D> query,
    Expression<Object> column,
    Object value,
    String fieldType,
  ) {
    switch (fieldType) {
      case 'int':
        query.where((t) => (column as Expression<int>)
          .isBiggerOrEqual(Variable<int>(value as int)));
        break;
      case 'double':
        query.where((t) => (column as Expression<double>)
          .isBiggerOrEqual(Variable<double>(value as double)));
        break;
      case 'DateTime':
        query.where((t) => (column as Expression<DateTime>)
          .isBiggerOrEqual(Variable<DateTime>(value as DateTime)));
        break;
    }
  }

  /// Apply less than operation with type safety
  void _applyLessThan(
    SimpleSelectStatement<Tbl, D> query,
    Expression<Object> column,
    Object value,
    String fieldType,
  ) {
    switch (fieldType) {
      case 'int':
        query.where((t) => (column as Expression<int>)
          .isSmallerThan(Variable<int>(value as int)));
        break;
      case 'double':
        query.where((t) => (column as Expression<double>)
          .isSmallerThan(Variable<double>(value as double)));
        break;
      case 'DateTime':
        query.where((t) => (column as Expression<DateTime>)
          .isSmallerThan(Variable<DateTime>(value as DateTime)));
        break;
    }
  }

  /// Apply less than or equal operation with type safety
  void _applyLessThanOrEqual(
    SimpleSelectStatement<Tbl, D> query,
    Expression<Object> column,
    Object value,
    String fieldType,
  ) {
    switch (fieldType) {
      case 'int':
        query.where((t) => (column as Expression<int>)
          .isSmallerOrEqual(Variable<int>(value as int)));
        break;
      case 'double':
        query.where((t) => (column as Expression<double>)
          .isSmallerOrEqual(Variable<double>(value as double)));
        break;
      case 'DateTime':
        query.where((t) => (column as Expression<DateTime>)
          .isSmallerOrEqual(Variable<DateTime>(value as DateTime)));
        break;
    }
  }

  /// Apply list filter (inList, notInList)
  void _applyListFilter(
    SimpleSelectStatement<Tbl, D> query,
    Expression<Object> column,
    FilterCondition filter,
    String? fieldType,
    bool isInList,
  ) {
    if (filter.value is ListValue) {
      final listValues = (filter.value as ListValue).values;
      
      switch (fieldType) {
        case 'String':
          final values = listValues.cast<String>();
          query.where((t) => isInList 
            ? (column as Expression<String>).isIn(values)
            : (column as Expression<String>).isNotIn(values));
          break;
        case 'int':
          final values = listValues.cast<int>();
          query.where((t) => isInList
            ? (column as Expression<int>).isIn(values)
            : (column as Expression<int>).isNotIn(values));
          break;
        case 'double':
          final values = listValues.cast<double>();
          query.where((t) => isInList
            ? (column as Expression<double>).isIn(values)
            : (column as Expression<double>).isNotIn(values));
          break;
        case 'bool':
          final values = listValues.cast<bool>();
          query.where((t) => isInList
            ? (column as Expression<bool>).isIn(values)
            : (column as Expression<bool>).isNotIn(values));
          break;
        case 'DateTime':
          final values = listValues.cast<DateTime>();
          query.where((t) => isInList
            ? (column as Expression<DateTime>).isIn(values)
            : (column as Expression<DateTime>).isNotIn(values));
          break;
        case 'SyncStatus':
          final statusNames = listValues.map((e) => e is SyncStatus ?
            e.name : e.toString()).toList();
          query.where((t) => isInList
            ? (column as Expression<String>).isIn(statusNames)
            : (column as Expression<String>).isNotIn(statusNames));
          break;
        default:
          // Fallback for unhandled types
          final values = listValues.cast<Object>();
          query.where((t) => isInList
            ? column.isIn(values)
            : column.isNotIn(values));
          break;
      }
    } else {
      throw ArgumentError('${isInList ? "inList" : "notInList"} '
      'operator requires a ListValue');
    }
  }

  /// Create ordering term for sorting
  OrderingTerm createOrderingTerm(SortCondition sort, Tbl table);

  /// The primary table this DAO operates on.
  TableInfo<Tbl, D> get table;
}


/// Typed field selectors for Post model
class PostFields {
  /// Field selector for id
  static const FieldSelector<String> id = 
      FieldSelector<String>('id', String);

  /// Field selector for title
  static const FieldSelector<String> title = 
      FieldSelector<String>('title', String);

  /// Field selector for body
  static const FieldSelector<String> body = 
      FieldSelector<String>('body', String);

  /// Field selector for userId
  static const FieldSelector<String> userId = 
      FieldSelector<String>('userId', String);

  /// Field selector for lastSyncedAt
  static const FieldSelector<DateTime> lastSyncedAt = 
      FieldSelector<DateTime>('lastSyncedAt', DateTime);

  /// Field selector for createdAt
  static const FieldSelector<DateTime> createdAt = 
      FieldSelector<DateTime>('createdAt', DateTime);

  /// Field selector for updatedAt
  static const FieldSelector<DateTime> updatedAt = 
      FieldSelector<DateTime>('updatedAt', DateTime);

  /// Field selector for syncStatus
  static const FieldSelector<SyncStatus> syncStatus = 
      FieldSelector<SyncStatus>('syncStatus', SyncStatus);

}



/// Data Access Object for Post operations
/// 
/// Provides CRUD operations and query methods for Post entities
/// in the SQLite database using Drift ORM.
@DriftAccessor(tables: [PostTable])
class PostDao extends DatabaseAccessor<SynquillDatabase>
    with _$PostDaoMixin,
       DaoHelpersMixin<PostTable, Post>, 
       BaseDaoMixin<Post> {
  /// Creates a new Post DAO instance
  PostDao(super.attachedDatabase);

  /// Get all posts as Drift data
  Future<List<Post>> getAllData() => select(postTable).get();

  /// Get post data by ID
  Future<Post?> getDataById(String id) =>
      (select(postTable)..where((t) =>
        t.id.equals(id))).getSingleOrNull();

  /// Get all posts as model objects
  Future<List<Post>> getAll({QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(postTable);
    applyQueryParams(query, queryParams);
    final dataList = await query.get();
    return dataList;
  }

  /// Get post by ID as model object
  Future<Post?> getById(String id, {QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(postTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    final data = await query.getSingleOrNull();
    return data;
  }

  /// Insert or update post
  Future<int> insertOrUpdate(PostTableCompanion entry) =>
      into(postTable).insertOnConflictUpdate(entry);

  /// Save post model
  Future<Post> saveModel(Post model) async {
    final companion = 
     PostTableCompanion(id: Value(model.id),
        title: Value(model.title),
        body: Value(model.body),
        userId: Value(model.userId),
        lastSyncedAt: Value(model.lastSyncedAt),
        createdAt: Value(model.createdAt ?? DateTime.now()),
        updatedAt: Value(model.updatedAt ?? DateTime.now()),
        syncStatus: Value(model.syncStatus ?? SyncStatus.synced));
    await insertOrUpdate(companion);
    return model;
  }

  /// Delete post by ID
  Future<int> deleteById(String id) =>
      (delete(postTable)..where((t) => t.id.equals(id))).go();

  /// Watch all posts as a stream
  Stream<List<Post>> watchAll({QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(postTable);
    applyQueryParams(query, queryParams);
    return query.watch();
  }

  /// Watch post by ID as a stream
  Stream<Post?> watchById(String id, {QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(postTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    return query.watchSingleOrNull();
  }

  /// The primary table this DAO operates on.
  @override
  TableInfo<PostTable, Post> get table => postTable;

  /// Get column expression for a field name
  @override
  Expression<Object>? getColumnForField(String fieldName) {
    switch (fieldName) {
      case 'id':
        return postTable.id;
      case 'title':
        return postTable.title;
      case 'body':
        return postTable.body;
      case 'userId':
        return postTable.userId;
      case 'lastSyncedAt':
        return postTable.lastSyncedAt;
      case 'createdAt':
        return postTable.createdAt;
      case 'updatedAt':
        return postTable.updatedAt;
      case 'syncStatus':
        return postTable.syncStatus;
      default:
        return null;
    }
  }

  /// Get the data type for a field name
  @override
  String? getFieldType(String fieldName) {
    switch (fieldName) {
      case 'id':
        return 'String';
      case 'title':
        return 'String';
      case 'body':
        return 'String';
      case 'userId':
        return 'String';
      case 'lastSyncedAt':
        return 'DateTime';
      case 'createdAt':
        return 'DateTime';
      case 'updatedAt':
        return 'DateTime';
      case 'syncStatus':
        return 'SyncStatus';
      default:
        return null;
    }
  }

  /// Create ordering term for sorting
  @override
  OrderingTerm createOrderingTerm(SortCondition sort, PostTable table) {
    final column = getColumnForField(sort.field.fieldName);
    if (column == null) {
      throw ArgumentError('Unknown field for sorting: ${sort.field.fieldName}');
    }

    return OrderingTerm(
      expression: column,
      mode: sort.direction == SortDirection.ascending
          ? OrderingMode.asc
          : OrderingMode.desc,
    );
  }

  // Implementation of BaseDaoMixin methods
  @override
  Future<Post?> getByIdTyped(String id, 
   {QueryParams? queryParams}) async {
    return await getById(id, queryParams: queryParams);
  }

  @override
  Future<List<Post>> getAllTyped({QueryParams? queryParams}) async {
    return await getAll(queryParams: queryParams);
  }

  @override
  Stream<Post?> watchByIdTyped(String id, {QueryParams? queryParams}) {
    return watchById(id, queryParams: queryParams);
  }

  @override
  Stream<List<Post>> watchAllTyped({QueryParams? queryParams}) {
    return watchAll(queryParams: queryParams);
  }

  /// Delete all posts from the table
  Future<int> deleteAll() =>
      delete(postTable).go();

}


/// Typed field selectors for LocalNote model
class LocalNoteFields {
  /// Field selector for id
  static const FieldSelector<String> id = 
      FieldSelector<String>('id', String);

  /// Field selector for ownerId
  static const FieldSelector<String> ownerId = 
      FieldSelector<String>('ownerId', String);

  /// Field selector for content
  static const FieldSelector<String> content = 
      FieldSelector<String>('content', String);

  /// Field selector for category
  static const FieldSelector<String> category = 
      FieldSelector<String>('category', String);

  /// Field selector for lastSyncedAt
  static const FieldSelector<DateTime> lastSyncedAt = 
      FieldSelector<DateTime>('lastSyncedAt', DateTime);

  /// Field selector for createdAt
  static const FieldSelector<DateTime> createdAt = 
      FieldSelector<DateTime>('createdAt', DateTime);

  /// Field selector for updatedAt
  static const FieldSelector<DateTime> updatedAt = 
      FieldSelector<DateTime>('updatedAt', DateTime);

  /// Field selector for syncStatus
  static const FieldSelector<SyncStatus> syncStatus = 
      FieldSelector<SyncStatus>('syncStatus', SyncStatus);

}



/// Data Access Object for LocalNote operations
/// 
/// Provides CRUD operations and query methods for LocalNote entities
/// in the SQLite database using Drift ORM.
@DriftAccessor(tables: [LocalNoteTable])
class LocalNoteDao extends DatabaseAccessor<SynquillDatabase>
    with _$LocalNoteDaoMixin,
       DaoHelpersMixin<LocalNoteTable, LocalNote>, 
       BaseDaoMixin<LocalNote> {
  /// Creates a new LocalNote DAO instance
  LocalNoteDao(super.attachedDatabase);

  /// Get all localnotes as Drift data
  Future<List<LocalNote>> getAllData() => select(localNoteTable).get();

  /// Get localnote data by ID
  Future<LocalNote?> getDataById(String id) =>
      (select(localNoteTable)..where((t) =>
        t.id.equals(id))).getSingleOrNull();

  /// Get all localnotes as model objects
  Future<List<LocalNote>> getAll({QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(localNoteTable);
    applyQueryParams(query, queryParams);
    final dataList = await query.get();
    return dataList;
  }

  /// Get localnote by ID as model object
  Future<LocalNote?> getById(String id, {QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(localNoteTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    final data = await query.getSingleOrNull();
    return data;
  }

  /// Insert or update localnote
  Future<int> insertOrUpdate(LocalNoteTableCompanion entry) =>
      into(localNoteTable).insertOnConflictUpdate(entry);

  /// Save localnote model
  Future<LocalNote> saveModel(LocalNote model) async {
    final companion = 
     LocalNoteTableCompanion(id: Value(model.id),
        ownerId: Value(model.ownerId),
        content: Value(model.content),
        category: Value(model.category),
        lastSyncedAt: Value(model.lastSyncedAt),
        createdAt: Value(model.createdAt ?? DateTime.now()),
        updatedAt: Value(model.updatedAt ?? DateTime.now()),
        syncStatus: Value(model.syncStatus ?? SyncStatus.synced));
    await insertOrUpdate(companion);
    return model;
  }

  /// Delete localnote by ID
  Future<int> deleteById(String id) =>
      (delete(localNoteTable)..where((t) => t.id.equals(id))).go();

  /// Watch all localnotes as a stream
  Stream<List<LocalNote>> watchAll({QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(localNoteTable);
    applyQueryParams(query, queryParams);
    return query.watch();
  }

  /// Watch localnote by ID as a stream
  Stream<LocalNote?> watchById(String id, {QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(localNoteTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    return query.watchSingleOrNull();
  }

  /// The primary table this DAO operates on.
  @override
  TableInfo<LocalNoteTable, LocalNote> get table => localNoteTable;

  /// Get column expression for a field name
  @override
  Expression<Object>? getColumnForField(String fieldName) {
    switch (fieldName) {
      case 'id':
        return localNoteTable.id;
      case 'ownerId':
        return localNoteTable.ownerId;
      case 'content':
        return localNoteTable.content;
      case 'category':
        return localNoteTable.category;
      case 'lastSyncedAt':
        return localNoteTable.lastSyncedAt;
      case 'createdAt':
        return localNoteTable.createdAt;
      case 'updatedAt':
        return localNoteTable.updatedAt;
      case 'syncStatus':
        return localNoteTable.syncStatus;
      default:
        return null;
    }
  }

  /// Get the data type for a field name
  @override
  String? getFieldType(String fieldName) {
    switch (fieldName) {
      case 'id':
        return 'String';
      case 'ownerId':
        return 'String';
      case 'content':
        return 'String';
      case 'category':
        return 'String';
      case 'lastSyncedAt':
        return 'DateTime';
      case 'createdAt':
        return 'DateTime';
      case 'updatedAt':
        return 'DateTime';
      case 'syncStatus':
        return 'SyncStatus';
      default:
        return null;
    }
  }

  /// Create ordering term for sorting
  @override
  OrderingTerm createOrderingTerm(SortCondition sort, LocalNoteTable table) {
    final column = getColumnForField(sort.field.fieldName);
    if (column == null) {
      throw ArgumentError('Unknown field for sorting: ${sort.field.fieldName}');
    }

    return OrderingTerm(
      expression: column,
      mode: sort.direction == SortDirection.ascending
          ? OrderingMode.asc
          : OrderingMode.desc,
    );
  }

  // Implementation of BaseDaoMixin methods
  @override
  Future<LocalNote?> getByIdTyped(String id, 
   {QueryParams? queryParams}) async {
    return await getById(id, queryParams: queryParams);
  }

  @override
  Future<List<LocalNote>> getAllTyped({QueryParams? queryParams}) async {
    return await getAll(queryParams: queryParams);
  }

  @override
  Stream<LocalNote?> watchByIdTyped(String id, {QueryParams? queryParams}) {
    return watchById(id, queryParams: queryParams);
  }

  @override
  Stream<List<LocalNote>> watchAllTyped({QueryParams? queryParams}) {
    return watchAll(queryParams: queryParams);
  }

  /// Delete all localnotes from the table
  Future<int> deleteAll() =>
      delete(localNoteTable).go();

}


/// Typed field selectors for PlainModel model
class PlainModelFields {
  /// Field selector for id
  static const FieldSelector<String> id = 
      FieldSelector<String>('id', String);

  /// Field selector for name
  static const FieldSelector<String> name = 
      FieldSelector<String>('name', String);

  /// Field selector for value
  static const FieldSelector<int> value = 
      FieldSelector<int>('value', int);

  /// Field selector for lastSyncedAt
  static const FieldSelector<DateTime> lastSyncedAt = 
      FieldSelector<DateTime>('lastSyncedAt', DateTime);

  /// Field selector for createdAt
  static const FieldSelector<DateTime> createdAt = 
      FieldSelector<DateTime>('createdAt', DateTime);

  /// Field selector for updatedAt
  static const FieldSelector<DateTime> updatedAt = 
      FieldSelector<DateTime>('updatedAt', DateTime);

  /// Field selector for syncStatus
  static const FieldSelector<SyncStatus> syncStatus = 
      FieldSelector<SyncStatus>('syncStatus', SyncStatus);

}



/// Data Access Object for PlainModel operations
/// 
/// Provides CRUD operations and query methods for PlainModel entities
/// in the SQLite database using Drift ORM.
@DriftAccessor(tables: [PlainModelTable])
class PlainModelDao extends DatabaseAccessor<SynquillDatabase>
    with _$PlainModelDaoMixin,
       DaoHelpersMixin<PlainModelTable, PlainModel>, 
       BaseDaoMixin<PlainModel> {
  /// Creates a new PlainModel DAO instance
  PlainModelDao(super.attachedDatabase);

  /// Get all plainmodels as Drift data
  Future<List<PlainModel>> getAllData() => select(plainModelTable).get();

  /// Get plainmodel data by ID
  Future<PlainModel?> getDataById(String id) =>
      (select(plainModelTable)..where((t) =>
        t.id.equals(id))).getSingleOrNull();

  /// Get all plainmodels as model objects
  Future<List<PlainModel>> getAll({QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(plainModelTable);
    applyQueryParams(query, queryParams);
    final dataList = await query.get();
    return dataList;
  }

  /// Get plainmodel by ID as model object
  Future<PlainModel?> getById(String id, {QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(plainModelTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    final data = await query.getSingleOrNull();
    return data;
  }

  /// Insert or update plainmodel
  Future<int> insertOrUpdate(PlainModelTableCompanion entry) =>
      into(plainModelTable).insertOnConflictUpdate(entry);

  /// Save plainmodel model
  Future<PlainModel> saveModel(PlainModel model) async {
    final companion = 
     PlainModelTableCompanion(id: Value(model.id),
        name: Value(model.name),
        value: Value(model.value),
        lastSyncedAt: Value(model.lastSyncedAt),
        createdAt: Value(model.createdAt ?? DateTime.now()),
        updatedAt: Value(model.updatedAt ?? DateTime.now()),
        syncStatus: Value(model.syncStatus ?? SyncStatus.synced));
    await insertOrUpdate(companion);
    return model;
  }

  /// Delete plainmodel by ID
  Future<int> deleteById(String id) =>
      (delete(plainModelTable)..where((t) => t.id.equals(id))).go();

  /// Watch all plainmodels as a stream
  Stream<List<PlainModel>> watchAll({QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(plainModelTable);
    applyQueryParams(query, queryParams);
    return query.watch();
  }

  /// Watch plainmodel by ID as a stream
  Stream<PlainModel?> watchById(String id, {QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(plainModelTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    return query.watchSingleOrNull();
  }

  /// The primary table this DAO operates on.
  @override
  TableInfo<PlainModelTable, PlainModel> get table => plainModelTable;

  /// Get column expression for a field name
  @override
  Expression<Object>? getColumnForField(String fieldName) {
    switch (fieldName) {
      case 'id':
        return plainModelTable.id;
      case 'name':
        return plainModelTable.name;
      case 'value':
        return plainModelTable.value;
      case 'lastSyncedAt':
        return plainModelTable.lastSyncedAt;
      case 'createdAt':
        return plainModelTable.createdAt;
      case 'updatedAt':
        return plainModelTable.updatedAt;
      case 'syncStatus':
        return plainModelTable.syncStatus;
      default:
        return null;
    }
  }

  /// Get the data type for a field name
  @override
  String? getFieldType(String fieldName) {
    switch (fieldName) {
      case 'id':
        return 'String';
      case 'name':
        return 'String';
      case 'value':
        return 'int';
      case 'lastSyncedAt':
        return 'DateTime';
      case 'createdAt':
        return 'DateTime';
      case 'updatedAt':
        return 'DateTime';
      case 'syncStatus':
        return 'SyncStatus';
      default:
        return null;
    }
  }

  /// Create ordering term for sorting
  @override
  OrderingTerm createOrderingTerm(SortCondition sort, PlainModelTable table) {
    final column = getColumnForField(sort.field.fieldName);
    if (column == null) {
      throw ArgumentError('Unknown field for sorting: ${sort.field.fieldName}');
    }

    return OrderingTerm(
      expression: column,
      mode: sort.direction == SortDirection.ascending
          ? OrderingMode.asc
          : OrderingMode.desc,
    );
  }

  // Implementation of BaseDaoMixin methods
  @override
  Future<PlainModel?> getByIdTyped(String id, 
   {QueryParams? queryParams}) async {
    return await getById(id, queryParams: queryParams);
  }

  @override
  Future<List<PlainModel>> getAllTyped({QueryParams? queryParams}) async {
    return await getAll(queryParams: queryParams);
  }

  @override
  Stream<PlainModel?> watchByIdTyped(String id, {QueryParams? queryParams}) {
    return watchById(id, queryParams: queryParams);
  }

  @override
  Stream<List<PlainModel>> watchAllTyped({QueryParams? queryParams}) {
    return watchAll(queryParams: queryParams);
  }

  /// Delete all plainmodels from the table
  Future<int> deleteAll() =>
      delete(plainModelTable).go();

}


/// Typed field selectors for User model
class UserFields {
  /// Field selector for id
  static const FieldSelector<String> id = 
      FieldSelector<String>('id', String);

  /// Field selector for name
  static const FieldSelector<String> name = 
      FieldSelector<String>('name', String);

  /// Field selector for lastSyncedAt
  static const FieldSelector<DateTime> lastSyncedAt = 
      FieldSelector<DateTime>('lastSyncedAt', DateTime);

  /// Field selector for createdAt
  static const FieldSelector<DateTime> createdAt = 
      FieldSelector<DateTime>('createdAt', DateTime);

  /// Field selector for updatedAt
  static const FieldSelector<DateTime> updatedAt = 
      FieldSelector<DateTime>('updatedAt', DateTime);

  /// Field selector for syncStatus
  static const FieldSelector<SyncStatus> syncStatus = 
      FieldSelector<SyncStatus>('syncStatus', SyncStatus);

}



/// Data Access Object for User operations
/// 
/// Provides CRUD operations and query methods for User entities
/// in the SQLite database using Drift ORM.
@DriftAccessor(tables: [UserTable])
class UserDao extends DatabaseAccessor<SynquillDatabase>
    with _$UserDaoMixin,
       DaoHelpersMixin<UserTable, User>, 
       BaseDaoMixin<User> {
  /// Creates a new User DAO instance
  UserDao(super.attachedDatabase);

  /// Get all users as Drift data
  Future<List<User>> getAllData() => select(userTable).get();

  /// Get user data by ID
  Future<User?> getDataById(String id) =>
      (select(userTable)..where((t) =>
        t.id.equals(id))).getSingleOrNull();

  /// Get all users as model objects
  Future<List<User>> getAll({QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(userTable);
    applyQueryParams(query, queryParams);
    final dataList = await query.get();
    return dataList;
  }

  /// Get user by ID as model object
  Future<User?> getById(String id, {QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(userTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    final data = await query.getSingleOrNull();
    return data;
  }

  /// Insert or update user
  Future<int> insertOrUpdate(UserTableCompanion entry) =>
      into(userTable).insertOnConflictUpdate(entry);

  /// Save user model
  Future<User> saveModel(User model) async {
    final companion = 
     UserTableCompanion(id: Value(model.id),
        name: Value(model.name),
        lastSyncedAt: Value(model.lastSyncedAt),
        createdAt: Value(model.createdAt ?? DateTime.now()),
        updatedAt: Value(model.updatedAt ?? DateTime.now()),
        syncStatus: Value(model.syncStatus ?? SyncStatus.synced));
    await insertOrUpdate(companion);
    return model;
  }

  /// Delete user by ID
  Future<int> deleteById(String id) =>
      (delete(userTable)..where((t) => t.id.equals(id))).go();

  /// Watch all users as a stream
  Stream<List<User>> watchAll({QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(userTable);
    applyQueryParams(query, queryParams);
    return query.watch();
  }

  /// Watch user by ID as a stream
  Stream<User?> watchById(String id, {QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(userTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    return query.watchSingleOrNull();
  }

  /// The primary table this DAO operates on.
  @override
  TableInfo<UserTable, User> get table => userTable;

  /// Get column expression for a field name
  @override
  Expression<Object>? getColumnForField(String fieldName) {
    switch (fieldName) {
      case 'id':
        return userTable.id;
      case 'name':
        return userTable.name;
      case 'lastSyncedAt':
        return userTable.lastSyncedAt;
      case 'createdAt':
        return userTable.createdAt;
      case 'updatedAt':
        return userTable.updatedAt;
      case 'syncStatus':
        return userTable.syncStatus;
      default:
        return null;
    }
  }

  /// Get the data type for a field name
  @override
  String? getFieldType(String fieldName) {
    switch (fieldName) {
      case 'id':
        return 'String';
      case 'name':
        return 'String';
      case 'lastSyncedAt':
        return 'DateTime';
      case 'createdAt':
        return 'DateTime';
      case 'updatedAt':
        return 'DateTime';
      case 'syncStatus':
        return 'SyncStatus';
      default:
        return null;
    }
  }

  /// Create ordering term for sorting
  @override
  OrderingTerm createOrderingTerm(SortCondition sort, UserTable table) {
    final column = getColumnForField(sort.field.fieldName);
    if (column == null) {
      throw ArgumentError('Unknown field for sorting: ${sort.field.fieldName}');
    }

    return OrderingTerm(
      expression: column,
      mode: sort.direction == SortDirection.ascending
          ? OrderingMode.asc
          : OrderingMode.desc,
    );
  }

  // Implementation of BaseDaoMixin methods
  @override
  Future<User?> getByIdTyped(String id, 
   {QueryParams? queryParams}) async {
    return await getById(id, queryParams: queryParams);
  }

  @override
  Future<List<User>> getAllTyped({QueryParams? queryParams}) async {
    return await getAll(queryParams: queryParams);
  }

  @override
  Stream<User?> watchByIdTyped(String id, {QueryParams? queryParams}) {
    return watchById(id, queryParams: queryParams);
  }

  @override
  Stream<List<User>> watchAllTyped({QueryParams? queryParams}) {
    return watchAll(queryParams: queryParams);
  }

  /// Delete all users from the table
  Future<int> deleteAll() =>
      delete(userTable).go();

}


/// Typed field selectors for Todo model
class TodoFields {
  /// Field selector for title
  static const FieldSelector<String> title = 
      FieldSelector<String>('title', String);

  /// Field selector for isCompleted
  static const FieldSelector<bool> isCompleted = 
      FieldSelector<bool>('isCompleted', bool);

  /// Field selector for userId
  static const FieldSelector<String> userId = 
      FieldSelector<String>('userId', String);

  /// Field selector for id
  static const FieldSelector<String> id = 
      FieldSelector<String>('id', String);

  /// Field selector for birthday
  static const FieldSelector<DateTime> birthday = 
      FieldSelector<DateTime>('birthday', DateTime);

  /// Field selector for fullName
  static const FieldSelector<String> fullName = 
      FieldSelector<String>('fullName', String);

  /// Field selector for avatarUrl
  static const FieldSelector<String> avatarUrl = 
      FieldSelector<String>('avatarUrl', String);

  /// Field selector for phoneNumber
  static const FieldSelector<String> phoneNumber = 
      FieldSelector<String>('phoneNumber', String);

  /// Field selector for email
  static const FieldSelector<String> email = 
      FieldSelector<String>('email', String);

  /// Field selector for fetchedAt
  static const FieldSelector<DateTime> fetchedAt = 
      FieldSelector<DateTime>('fetchedAt', DateTime);

  /// Field selector for lastSyncedAt
  static const FieldSelector<DateTime> lastSyncedAt = 
      FieldSelector<DateTime>('lastSyncedAt', DateTime);

  /// Field selector for createdAt
  static const FieldSelector<DateTime> createdAt = 
      FieldSelector<DateTime>('createdAt', DateTime);

  /// Field selector for updatedAt
  static const FieldSelector<DateTime> updatedAt = 
      FieldSelector<DateTime>('updatedAt', DateTime);

  /// Field selector for syncStatus
  static const FieldSelector<SyncStatus> syncStatus = 
      FieldSelector<SyncStatus>('syncStatus', SyncStatus);

}



/// Data Access Object for Todo operations
/// 
/// Provides CRUD operations and query methods for Todo entities
/// in the SQLite database using Drift ORM.
@DriftAccessor(tables: [TodoTable])
class TodoDao extends DatabaseAccessor<SynquillDatabase>
    with _$TodoDaoMixin,
       DaoHelpersMixin<TodoTable, Todo>, 
       BaseDaoMixin<Todo> {
  /// Creates a new Todo DAO instance
  TodoDao(super.attachedDatabase);

  /// Get all todos as Drift data
  Future<List<Todo>> getAllData() => select(todoTable).get();

  /// Get todo data by ID
  Future<Todo?> getDataById(String id) =>
      (select(todoTable)..where((t) =>
        t.id.equals(id))).getSingleOrNull();

  /// Get all todos as model objects
  Future<List<Todo>> getAll({QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(todoTable);
    applyQueryParams(query, queryParams);
    final dataList = await query.get();
    return dataList;
  }

  /// Get todo by ID as model object
  Future<Todo?> getById(String id, {QueryParams? queryParams}) async {
    queryParams ??= QueryParams.empty;
    final query = select(todoTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    final data = await query.getSingleOrNull();
    return data;
  }

  /// Insert or update todo
  Future<int> insertOrUpdate(TodoTableCompanion entry) =>
      into(todoTable).insertOnConflictUpdate(entry);

  /// Save todo model
  Future<Todo> saveModel(Todo model) async {
    final companion = 
     TodoTableCompanion(title: Value(model.title),
        isCompleted: Value(model.isCompleted),
        userId: Value(model.userId),
        id: Value(model.id),
        birthday: Value(model.birthday),
        fullName: Value(model.fullName),
        avatarUrl: Value(model.avatarUrl),
        phoneNumber: Value(model.phoneNumber),
        email: Value(model.email),
        fetchedAt: Value(model.fetchedAt),
        lastSyncedAt: Value(model.lastSyncedAt),
        createdAt: Value(model.createdAt ?? DateTime.now()),
        updatedAt: Value(model.updatedAt ?? DateTime.now()),
        syncStatus: Value(model.syncStatus ?? SyncStatus.synced));
    await insertOrUpdate(companion);
    return model;
  }

  /// Delete todo by ID
  Future<int> deleteById(String id) =>
      (delete(todoTable)..where((t) => t.id.equals(id))).go();

  /// Watch all todos as a stream
  Stream<List<Todo>> watchAll({QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(todoTable);
    applyQueryParams(query, queryParams);
    return query.watch();
  }

  /// Watch todo by ID as a stream
  Stream<Todo?> watchById(String id, {QueryParams? queryParams}) {
    queryParams ??= QueryParams.empty;
    final query = select(todoTable)..where((t) => t.id.equals(id));
    applyQueryParams(query, queryParams);
    return query.watchSingleOrNull();
  }

  /// The primary table this DAO operates on.
  @override
  TableInfo<TodoTable, Todo> get table => todoTable;

  /// Get column expression for a field name
  @override
  Expression<Object>? getColumnForField(String fieldName) {
    switch (fieldName) {
      case 'title':
        return todoTable.title;
      case 'isCompleted':
        return todoTable.isCompleted;
      case 'userId':
        return todoTable.userId;
      case 'id':
        return todoTable.id;
      case 'birthday':
        return todoTable.birthday;
      case 'fullName':
        return todoTable.fullName;
      case 'avatarUrl':
        return todoTable.avatarUrl;
      case 'phoneNumber':
        return todoTable.phoneNumber;
      case 'email':
        return todoTable.email;
      case 'fetchedAt':
        return todoTable.fetchedAt;
      case 'lastSyncedAt':
        return todoTable.lastSyncedAt;
      case 'createdAt':
        return todoTable.createdAt;
      case 'updatedAt':
        return todoTable.updatedAt;
      case 'syncStatus':
        return todoTable.syncStatus;
      default:
        return null;
    }
  }

  /// Get the data type for a field name
  @override
  String? getFieldType(String fieldName) {
    switch (fieldName) {
      case 'title':
        return 'String';
      case 'isCompleted':
        return 'bool';
      case 'userId':
        return 'String';
      case 'id':
        return 'String';
      case 'birthday':
        return 'DateTime';
      case 'fullName':
        return 'String';
      case 'avatarUrl':
        return 'String';
      case 'phoneNumber':
        return 'String';
      case 'email':
        return 'String';
      case 'fetchedAt':
        return 'DateTime';
      case 'lastSyncedAt':
        return 'DateTime';
      case 'createdAt':
        return 'DateTime';
      case 'updatedAt':
        return 'DateTime';
      case 'syncStatus':
        return 'SyncStatus';
      default:
        return null;
    }
  }

  /// Create ordering term for sorting
  @override
  OrderingTerm createOrderingTerm(SortCondition sort, TodoTable table) {
    final column = getColumnForField(sort.field.fieldName);
    if (column == null) {
      throw ArgumentError('Unknown field for sorting: ${sort.field.fieldName}');
    }

    return OrderingTerm(
      expression: column,
      mode: sort.direction == SortDirection.ascending
          ? OrderingMode.asc
          : OrderingMode.desc,
    );
  }

  // Implementation of BaseDaoMixin methods
  @override
  Future<Todo?> getByIdTyped(String id, 
   {QueryParams? queryParams}) async {
    return await getById(id, queryParams: queryParams);
  }

  @override
  Future<List<Todo>> getAllTyped({QueryParams? queryParams}) async {
    return await getAll(queryParams: queryParams);
  }

  @override
  Stream<Todo?> watchByIdTyped(String id, {QueryParams? queryParams}) {
    return watchById(id, queryParams: queryParams);
  }

  @override
  Stream<List<Todo>> watchAllTyped({QueryParams? queryParams}) {
    return watchAll(queryParams: queryParams);
  }

  /// Delete all todos from the table
  Future<int> deleteAll() =>
      delete(todoTable).go();

}



