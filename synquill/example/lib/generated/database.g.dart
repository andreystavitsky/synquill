// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by synquill aggregate_builder

part of 'database.generated.dart';

/// Defines the schema for an item in the synchronization queue.
///
/// Each row represents an operation (create, update, delete) on a data
/// model that needs to be synced with a remote server.
@DataClassName('SyncQueueItem')
@TableIndex(name: 'idx_model_id', columns: {#modelId})
@TableIndex(name: 'idx_model_type', columns: {#modelType})
@TableIndex(name: 'idx_operation', columns: {#operation})
@TableIndex(name: 'idx_status', columns: {#status})
@TableIndex(name: 'idx_next_retry_at', columns: {#nextRetryAt})
@TableIndex(name: 'idx_created_at', columns: {#createdAt})
@TableIndex(
  name: 'idx_temporary_client_id', 
  columns: {#temporaryClientId},
  unique: true)
@TableIndex(name: 'idx_id_negotiation_status', columns: {#idNegotiationStatus})
class SyncQueueItems extends Table {
  /// Unique identifier for the queue item.
  IntColumn get id => integer().autoIncrement()();

  /// The type of the model being synced (e.g., "User", "Product").
  TextColumn get modelType => text().named('model_type')();

  /// The ID of the specific model instance being synced.
  TextColumn get modelId => text().named('model_id')();
  
  /// Temporary client ID for models using server-generated IDs.
  /// Used to track the original temporary ID before server ID replacement.
  TextColumn get temporaryClientId => text()
    .named('temporary_client_id')
    .nullable()();
  
  /// ID negotiation status for server-generated ID models.
  /// Values: 'complete', 'pending', 'failed'
  TextColumn get idNegotiationStatus => text().named('id_negotiation_status')
      .withDefault(const Constant('complete'))();

  /// JSON string representation of the model data.
  /// For 'delete' operations, this might store the ID or key fields.
  TextColumn get payload => text()();

  /// The synchronization operation type (create, update, delete).
  TextColumn get operation => text().named('op')();

  /// Number of times a synchronization attempt has been made.
  IntColumn get attemptCount =>
      integer().named('attempt_count').withDefault(const Constant(0))();

  /// Stores the error message from the last failed sync attempt.
  TextColumn get lastError => text().named('last_error').nullable()();

  /// When the next synchronization attempt should occur.
  /// Null if ready for immediate processing or retries are exhausted.
  DateTimeColumn get nextRetryAt =>
      dateTime().named('next_retry_at').nullable()();

  /// Timestamp of when this item was added to the queue.
  DateTimeColumn get createdAt =>
      dateTime().named('created_at').withDefault(currentDateAndTime)();

  /// Optional idempotency key for ensuring network operations are not
  /// duplicated if a retry occurs after a successful but unconfirmed
  /// operation.
  TextColumn get idempotencyKey =>
      text().named('idempotency_key').nullable().unique()();

  /// Status of the sync queue item (pending, synced, dead).
  TextColumn get status => text().withDefault(const Constant('synced'))();

  /// JSON string representation of HTTP headers for the sync operation.
  /// Stored as nullable text to preserve headers for retry operations.
  TextColumn get headers => text().nullable()();

  /// JSON string representation of extra parameters for the sync operation.
  /// Stored as nullable text to preserve extra data for retry operations.
  TextColumn get extra => text().nullable()();

  @override
  List<Set<Column>> get uniqueKeys => [
    {modelId, operation}, // Ensure only one operation per model ID
  ];
}


@DriftDatabase(
  tables: [
    SyncQueueItems,
    PostTable,
    LocalNoteTable,
    PlainModelTable,
    UserTable,
    TodoTable,
  ],
  daos: [
    PostDao,
    LocalNoteDao,
    PlainModelDao,
    UserDao,
    TodoDao,
  ],
)
/// Main database class for synced data storage
/// 
/// Provides Drift-powered offline storage with automatic sync capabilities.
/// Includes all generated tables and DAOs for the configured models.
class SynquillDatabase extends _$SynquillDatabase {
  static Logger get _log {
    try {
      return SynquillStorage.logger;
    } catch (_) {
      return Logger('SynquillDatabase');
    }
  }

  /// Optional callback for when database is created.
  final Future<void> Function(Migrator)? _onDatabaseCreated;

  /// Optional callback for custom migration logic.
  final Future<void> Function(Migrator, int, int)? _onCustomMigration;

  /// Creates a new SynquillDatabase instance
  /// 
  /// [executor] The database executor (usually a file-based connection)
  /// [onDatabaseCreated] Optional callback for initial database setup
  /// [onCustomMigration] Optional callback for handling database migrations
  SynquillDatabase(
    super.executor, {
    Future<void> Function(Migrator)? onDatabaseCreated,
    Future<void> Function(Migrator, int, int)? onCustomMigration,
  }) : _onDatabaseCreated = onDatabaseCreated,
       _onCustomMigration = onCustomMigration;

  late final SyncQueueDao _syncQueueDao = SyncQueueDao(this);

  @override
  int get schemaVersion => 1;

  /// Provides migration strategy for schema upgrades.
  ///
  /// The default implementation handles basic table creation and provides
  /// a foundation for custom migration logic. Override [onCustomMigration]
  /// to add application-specific migration steps.
  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (m) async {
        _log.info('Creating database schema');
        await m.createAll();
        if (_onDatabaseCreated != null) {
          await _onDatabaseCreated!(m);
        } else {
          await onDatabaseCreated(m);
        }
      },
      onUpgrade: (m, from, to) async {
        _log.info('Upgrading database from version $from to $to');
        if (_onCustomMigration != null) {
          await _onCustomMigration!(m, from, to);
        } else {
          await onCustomMigration(m, from, to);
        }
      },
    );
  }

  /// Called when the database is created for the first time.
  /// Override this to add initial data or perform setup tasks.
  Future<void> onDatabaseCreated(Migrator migrator) async {
    _log.info('Database created successfully');
    // Override in subclasses to add initial data
  }

  /// Called when the database needs to be upgraded to a new schema version.
  /// Override this to handle custom migration logic.
  ///
  /// Example:
  /// ```dart
  /// @override
  /// Future<void> onCustomMigration(Migrator m, int from, int to) async {
  ///   if (from < 2) {
  ///     await m.addColumn(users, users.newColumn);
  ///   }
  ///   if (from < 3) {
  ///     await m.createTable(newTable);
  ///   }
  /// }
  /// ```
  Future<void> onCustomMigration(Migrator migrator, int from, int to) async {
    _log.info('No custom migration logic defined');
    // Override in subclasses to handle migrations
  }

  /// Provides access to the core SyncQueueDao
  SyncQueueDao get syncQueueDao => _syncQueueDao;

  /// Returns user-defined table types
  List<Type> get userDefinedTables => [
    PostTable,
    LocalNoteTable,
    PlainModelTable,
    UserTable,
    TodoTable,
  ];

  /// Returns user-defined DAO types
  List<Type> get userDefinedDaos => [
    PostDao,
    LocalNoteDao,
    PlainModelDao,
    UserDao,
    TodoDao,
  ];

  /// Closes the database connection.
  ///
  /// This method should be called when the database is no longer needed
  /// to ensure proper cleanup of resources.
  @override
  Future<void> close() async {
    _log.info('Closing database connection');
    await super.close();
  }
}

